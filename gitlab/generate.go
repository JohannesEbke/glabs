package gitlab

import (
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/xanzy/go-gitlab"
)

func (c *Client) Generate(group string, assignment string, template string) {
	if groupInfo := viper.GetStringMap(group); len(groupInfo) == 0 {
		log.Info().Str("group", group).Msg("goup not found")
		return
	}

	assignmentKey := group + "." + assignment

	if assignmentConfig := viper.GetStringMap(assignmentKey); len(assignmentConfig) == 0 {
		log.Info().Str("assignment", assignment).Msg("no configuration for assignment found")
		return
	}

	if inID := viper.GetInt(assignmentKey + ".inID"); inID == 0 {
		log.Info().Str("assignment", assignment).Msg("please specify inID for assignment")
		return
	}

	switch viper.GetString(assignmentKey + ".per") {
	case "group":
		log.Info().Msg("generating per group")
	case "student", "":
		log.Info().Msg("generating per student")
		c.generatePerStudent(group, assignment)
	default:
		log.Info().Msg("generating per unknown")
		return
	}
}

func (c *Client) generatePerStudent(group string, assignment string) {
	students := viper.GetStringSlice(group + ".students")
	if len(students) == 0 {
		log.Info().Str("group", group).Msg("no students found")
		return
	}

	for _, student := range students {
		inID := viper.GetInt(group + "." + assignment + ".inId")
		c.generateForStudent(student, group, assignment, inID)
	}
}

//nolint:funlen
func (c *Client) generateForStudent(student string, group string, assignment string, inID int) {
	u := &gitlab.ListUsersOptions{
		Username: gitlab.String(student),
	}
	users, _, err := c.Users.ListUsers(u)
	if err != nil {
		log.Fatal().Err(err)
	}

	if len(users) == 0 {
		log.Info().Str("username", student).Msg("user not found")
		return
	} else if len(users) > 1 {
		log.Info().Str("username", student).Msg("more than one user found")
		return
	}

	userID := users[0].ID
	log.Debug().Str("username", student).Int("userID", userID).Msg("found user with id")

	name := assignment + "-" + student
	description := "generated by glabs"

	if desc := viper.GetString(group + "." + assignment + ".description"); desc != "" {
		description = desc
	}

	log.Debug().Str("desciption", description).Msg("generating with description")

	p := &gitlab.CreateProjectOptions{
		Name:                     gitlab.String(name),
		Description:              gitlab.String(description),
		NamespaceID:              gitlab.Int(inID),
		MergeRequestsAccessLevel: gitlab.AccessControl("enabled"),
		IssuesAccessLevel:        gitlab.AccessControl("enabled"),
		BuildsAccessLevel:        gitlab.AccessControl("enabled"),
		Visibility:               gitlab.Visibility(gitlab.PrivateVisibility),
	}

	project, _, err := c.Projects.CreateProject(p)

	if err != nil {
		if project == nil {
			projectname := group + "/semester/ob-20ws/test/" + name
			log.Debug().Str("name", projectname).Msg("searching for project")
			opt := &gitlab.ListProjectsOptions{
				Search:           gitlab.String(group + "/semester/ob-20ws/test/" + name),
				SearchNamespaces: gitlab.Bool(true),
			}
			projects, _, err := c.Projects.ListProjects(opt)
			if err != nil {
				log.Fatal().Err(err)
			} else {
				if len(projects) == 1 {
					project = projects[0]
				} else {
					return
				}
			}
		} else {
			log.Fatal().Err(err)
		}
	} else {
		log.Debug().Str("name", name).Msg("generated repo")
	}

	developer := 30
	m := &gitlab.AddProjectMemberOptions{
		UserID:      gitlab.Int(userID),
		AccessLevel: gitlab.AccessLevel(gitlab.AccessLevelValue(developer)),
	}
	_, _, err = c.ProjectMembers.AddProjectMember(project.ID, m)
	if err != nil {
		log.Fatal().Err(err)
	} else {
		log.Debug().Str("name", name).Msg("granted developer access to repo")
	}
}
