package gitlab

import (
	"errors"
	"strings"

	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
	"github.com/xanzy/go-gitlab"
)

func (c *Client) Generate(group, assignment, template string) {
	if groupInfo := viper.GetStringMap(group); len(groupInfo) == 0 {
		log.Info().Str("group", group).Msg("goup not found")
		return
	}

	assignmentKey := group + "." + assignment

	if assignmentConfig := viper.GetStringMap(assignmentKey); len(assignmentConfig) == 0 {
		log.Info().Str("assignment", assignment).Msg("no configuration for assignment found")
		return
	}

	assignmentGroupID, assignmentPath, err := c.getGroupID(group, assignmentKey)
	if err != nil {
		log.Error().Err(err).Str("assignment", assignment).Msg("group for assignment does not exist")
		return
	}

	switch viper.GetString(assignmentKey + ".per") {
	case "group":
		log.Info().Msg("generating per group")
	case "student", "":
		log.Info().Msg("generating per student")
		c.generatePerStudent(group, assignment, assignmentPath, assignmentGroupID)
	default:
		log.Info().Msg("generating per unknown")
		return
	}
}

func (c *Client) getGroupID(group, assignmentKey string) (int, string, error) {
	semesterGroup := group
	if semestergroup := viper.GetString(group + ".semestergroup"); len(semestergroup) > 0 {
		semesterGroup += "/" + semestergroup
	}

	assignmentGroup := semesterGroup
	if group := viper.GetString(assignmentKey + ".group"); len(group) > 0 {
		assignmentGroup += "/" + group
	}

	groupnames := strings.Split(assignmentGroup, "/")
	groups, _, err := c.Groups.SearchGroup(groupnames[len(groupnames)-1])

	if err != nil {
		log.Error().Err(err).Str("group", group).Msg("error while searching id of group")
		return 0, "", err
	}

	if len(groups) == 0 {
		log.Debug().Str("group", group).Msg("no group found")
		return 0, "", errors.New("no group found")
	}

	log.Debug().Str("assignmentGroup", assignmentGroup).Msg("searching id of group")

	// semesterGroupID := 0
	assignmentGroupID := 0

	for _, group := range groups {
		// if group.Path == semesterGroup {
		// 	log.Debug().Str("group.Path", group.Path).Msg("found semester group")
		// 	semesterGroupID = group.ID
		// }
		if group.FullPath == assignmentGroup {
			log.Debug().Str("group.FullPath", group.FullPath).Msg("found assignment group")
			assignmentGroupID = group.ID
		}
	}

	if assignmentGroupID == 0 {
		log.Info().Msg("creating assignment group")
		panic("implement me")
	}

	return assignmentGroupID, assignmentGroup, nil
}

func (c *Client) generatePerStudent(group, assignment, assignmentPath string, assignmentGroupID int) {
	students := viper.GetStringSlice(group + ".students")
	if len(students) == 0 {
		log.Info().Str("group", group).Msg("no students found")
		return
	}

	for _, student := range students {
		c.generateForStudent(student, group, assignment, assignmentPath, assignmentGroupID)
	}
}

//nolint:funlen
func (c *Client) generateForStudent(student, group, assignment, assignmentPath string, inID int) {
	u := &gitlab.ListUsersOptions{
		Username: gitlab.String(student),
	}
	users, _, err := c.Users.ListUsers(u)
	if err != nil {
		log.Fatal().Err(err)
	}

	if len(users) == 0 {
		log.Info().Str("username", student).Msg("user not found")
		return
	} else if len(users) > 1 {
		log.Info().Str("username", student).Msg("more than one user found")
		return
	}

	userID := users[0].ID
	log.Debug().Str("username", student).Int("userID", userID).Msg("found user with id")

	name := assignment + "-" + student
	description := "generated by glabs"

	if desc := viper.GetString(group + "." + assignment + ".description"); desc != "" {
		description = desc
	}

	log.Debug().Str("desciption", description).Msg("generating with description")

	p := &gitlab.CreateProjectOptions{
		Name:                     gitlab.String(name),
		Description:              gitlab.String(description),
		NamespaceID:              gitlab.Int(inID),
		MergeRequestsAccessLevel: gitlab.AccessControl("enabled"),
		IssuesAccessLevel:        gitlab.AccessControl("enabled"),
		BuildsAccessLevel:        gitlab.AccessControl("enabled"),
		JobsEnabled:              gitlab.Bool(true),
		Visibility:               gitlab.Visibility(gitlab.PrivateVisibility),
	}

	project, _, err := c.Projects.CreateProject(p)

	if err != nil {
		if project == nil {
			projectname := assignmentPath + "/" + name
			log.Debug().Str("name", projectname).Msg("searching for project")
			opt := &gitlab.ListProjectsOptions{
				Search:           gitlab.String(projectname),
				SearchNamespaces: gitlab.Bool(true),
			}
			projects, _, err := c.Projects.ListProjects(opt)
			if err != nil {
				log.Fatal().Err(err)
			} else {
				if len(projects) == 1 {
					project = projects[0]
				} else {
					log.Debug().Interface("projects", projects).Msg("more than one project found")
					return
				}
			}
		} else {
			log.Fatal().Err(err)
		}
	} else {
		log.Debug().Str("name", name).Msg("generated repo")
	}

	accesslevel := 30 // Developer

	if accesslevelIdentifier := viper.GetString(group + "." + assignment + ".accesslevel"); accesslevelIdentifier != "" {
		switch accesslevelIdentifier {
		case "guest":
			accesslevel = 10
		case "reporter":
			accesslevel = 20
		case "maintainer":
			accesslevel = 40
		}
	}
	c.addMember(project.ID, userID, accesslevel, name)
}

func (c *Client) addMember(projectID, userID, accesslevel int, reponame string) {
	m := &gitlab.AddProjectMemberOptions{
		UserID:      gitlab.Int(userID),
		AccessLevel: gitlab.AccessLevel(gitlab.AccessLevelValue(accesslevel)),
	}
	_, _, err := c.ProjectMembers.AddProjectMember(projectID, m)
	if err != nil {
		log.Fatal().Err(err)
	} else {
		log.Debug().Str("name", reponame).Msg("granted developer access to repo")
	}
}
